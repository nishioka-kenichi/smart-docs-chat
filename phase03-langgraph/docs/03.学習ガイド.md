# Phase 3 LangGraphエージェント - 学習ガイド

## 📚 AIエージェント開発を学ぶためのコードレビューガイド

本ガイドは、Phase 3のコードを通じてAIエージェントの仕組みを体系的に学習するための道筋を示します。
初学者から上級者まで、段階的に理解を深められる構成になっています。

---

## 🎯 学習目標

このガイドを通じて以下を習得できます：

1. **AIエージェントの基本概念**
   - 状態管理とメモリ
   - ReActパターン（Reasoning + Acting）
   - ツールの抽象化と連携

2. **LangGraphの活用方法**
   - グラフベースの処理フロー
   - 条件付き分岐とルーティング
   - チェックポイントによる永続化

3. **実践的な実装スキル**
   - プロンプトエンジニアリング
   - エラーハンドリング
   - カスタマイズと拡張

---

## 📖 推奨学習順序

### 第1段階：基礎概念の理解（1-2時間）

#### 1️⃣ **agent_state.py** - エージェントの「記憶」を理解

エージェントがどのような情報を保持し、どのように状態を管理するかを学びます。

```python
# 学習ポイント：
# - エージェントが何を記憶するか
# - 状態遷移の概念
# - TypedDictによる型安全な状態管理

# 重点的に見るべき箇所：
class AgentState(TypedDict):  # エージェントの全状態
    messages: Annotated[List[BaseMessage], operator.add]  # 会話履歴
    reasoning_steps: List[ReasoningStep]  # 思考過程
    tool_calls: List[ToolCall]  # ツール使用履歴
    
# 状態操作の基本パターン
def create_initial_state()  # 初期化
def add_reasoning_step()     # 履歴追加
def should_continue()        # 継続判定
```

**理解度チェック**:
- [ ] AgentStateの各フィールドの役割を説明できる
- [ ] 状態がimmutableである理由を理解している
- [ ] Annotatedの使い方とoperator.addの意味を理解している

---

### 第2段階：ReActパターンの理解（2-3時間）

#### 2️⃣ **react_agent.py** - AIエージェントの「思考」を理解

ReActパターンの実装を通じて、エージェントの推論プロセスを学びます。

```python
# 学習ポイント：
# - ReActパターン（Reasoning + Acting）
# - LLMへのプロンプト設計
# - 思考→行動→観察のループ

# 重要な4つのメソッドを順に理解：
def reason()   # 1. 推論：次に何をすべきか考える
def act()      # 2. 行動：ツールを実行
def observe()  # 3. 観察：結果を確認
def answer()   # 4. 回答：最終的な答えを生成

# プロンプトテンプレートの理解
self.system_prompt  # ReActパターンの指示
self.react_prompt   # 段階的思考の誘導
```

**理解度チェック**:
- [ ] ReActループの流れを図で描ける
- [ ] 各メソッドの役割と相互関係を説明できる
- [ ] プロンプトの構造と意図を理解している

---

### 第3段階：ツールとの連携（1-2時間）

#### 3️⃣ **tools.py** - エージェントの「能力」を理解

エージェントが外部機能をどのように活用するかを学びます。

```python
# 学習ポイント：
# - ツールの抽象化
# - 入力/出力のスキーマ定義
# - エラーハンドリング

# ツールパターンの理解：
class ToolsManager:
    def _setup_rag_search()   # 検索ツール
    def _setup_calculator()   # 計算ツール
    
# StructuredToolの使い方
tool = StructuredTool.from_function(
    func=実行関数,
    name=ツール名,
    description=説明,
    args_schema=入力スキーマ
)
```

**理解度チェック**:
- [ ] ツールの追加方法を理解している
- [ ] Pydanticスキーマの役割を説明できる
- [ ] エラーハンドリングの重要性を理解している

---

### 第4段階：オーケストレーション（2-3時間）

#### 4️⃣ **graph_builder.py** - 処理フローの「制御」を理解

LangGraphを使用した処理フローの構築方法を学びます。

```python
# 学習ポイント：
# - グラフベースの状態遷移
# - 条件付き分岐
# - ノードとエッジの概念

# グラフ構築パターン：
workflow.add_node("reason", self._reason_node)  # ノード追加
workflow.add_edge("start", "reason")            # 固定遷移
workflow.add_conditional_edges(                 # 条件付き遷移
    "reason",
    self._route_after_reason,
    {"act": "act", "answer": "answer"}
)

# ルーティングロジック
def _route_after_reason()  # 次のノードを決定
```

**理解度チェック**:
- [ ] グラフの構造を図示できる
- [ ] 条件付き遷移のロジックを説明できる
- [ ] 新しいノードを追加する方法を理解している

---

### 第5段階：永続化と回復（1-2時間）

#### 5️⃣ **checkpointer.py** - 「記憶の保存」を理解

エージェントの状態を永続化し、エラーから回復する仕組みを学びます。

```python
# 学習ポイント：
# - 状態の永続化戦略
# - エラー回復の仕組み
# - メタデータ管理

def save_checkpoint()   # 状態保存
def load_checkpoint()   # 状態復元
def _cleanup_old_checkpoints()  # 自動クリーンアップ
```

**理解度チェック**:
- [ ] チェックポイントの必要性を説明できる
- [ ] 圧縮保存のメリット・デメリットを理解している
- [ ] 自動クリーンアップの仕組みを説明できる

---

### 第6段階：統合と実行（1-2時間）

#### 6️⃣ **main.py** - 全体の「統合」を理解

すべてのコンポーネントがどのように連携するかを学びます。

```python
# 学習ポイント：
# - コンポーネントの統合
# - ユーザーインターフェース
# - エラーハンドリング

class LangGraphAgent:
    def _initialize_components()  # 初期化の流れ
    def run_single()             # 単一実行
    def run_interactive()        # 対話モード
```

**理解度チェック**:
- [ ] 初期化の順序と依存関係を理解している
- [ ] 対話モードの実装方法を説明できる
- [ ] コマンド処理の仕組みを理解している

---

## 💡 実践的な学習方法

### 1. 各ファイルを独立実行して学習

```bash
# Phase 3ディレクトリに移動
cd phase03-langgraph

# 仮想環境を有効化
source .venv/bin/activate

# デモファイルを実行して学習
python examples/demo_agent_state.py    # State管理を学習
python examples/demo_tools.py          # ツールの動作を確認
python examples/demo_react_agent.py    # ReActパターンを理解
python examples/demo_checkpointer.py   # チェックポイント機能を確認
python examples/demo_graph_builder.py  # グラフ構造を理解
```

### 2. デバッガーを使った詳細な追跡

```python
# VSCodeでデバッグ設定を作成
# .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug Main",
            "type": "python",
            "request": "launch",
            "program": "${workspaceFolder}/src/main.py",
            "console": "integratedTerminal",
            "cwd": "${workspaceFolder}",
            "args": ["テスト質問"]
        },
        {
            "name": "Debug Demo",
            "type": "python",
            "request": "launch",
            "program": "${workspaceFolder}/examples/demo_react_agent.py",
            "console": "integratedTerminal",
            "cwd": "${workspaceFolder}"
        }
    ]
}

# ブレークポイントを設定すべき箇所：
# - agent_state.py: create_initial_state()関数
# - react_agent.py: reason()メソッドの開始
# - tools.py: _calculate()関数
# - graph_builder.py: _route_after_reason()

```

### 3. ログ出力による理解

```python
# 詳細ログを有効にして実行
# settings.yamlで設定
# logging:
#   level: "DEBUG"

# または実行時に詳細モードを指定
python src/main.py "テスト質問"  # verboseがデフォルトでTrue

# 詳細ログを無効にする場合
python src/main.py --quiet "テスト質問"
```

### 4. 段階的な改造

#### Step 1: 簡単なツールを追加

```python
# tools.pyに新しいツールを追加
def _setup_time_tool(self):
    """現在時刻を返すツール"""
    from datetime import datetime
    
    tool = StructuredTool.from_function(
        func=lambda: f"現在時刻: {datetime.now()}",
        name="current_time",
        description="現在の日時を取得"
    )
    self.tools.append(tool)
```

#### Step 2: 新しいノードを追加

```python
# graph_builder.pyに検証ノードを追加
def _validate_node(self, state: AgentState) -> AgentState:
    """回答の妥当性を検証"""
    if state.get("final_answer"):
        # 検証ロジック
        state["metadata"]["validated"] = True
    return state

# グラフに組み込み
workflow.add_node("validate", self._validate_node)
workflow.add_edge("answer", "validate")
```

#### Step 3: プロンプトのカスタマイズ

```python
# react_agent.pyでプロンプトを変更
self.system_prompt = """
あなたは親切で正確なAIアシスタントです。
ReActパターンに従い、以下のプロセスで回答してください：

1. 質問を理解し、必要な情報を特定する（Reasoning）
2. 適切なツールを選択して実行する（Acting）
3. 結果を確認し、追加情報が必要か判断する（Observation）

重要：推論過程を明確に説明してください。
"""
```

---

## 📊 学習進捗チェックリスト

### 初級レベル（基本理解）

- [ ] 各ファイルの役割を説明できる
- [ ] AgentStateの構造を理解している
- [ ] ReActパターンの基本を説明できる
- [ ] 簡単なテストを実行できる

### 中級レベル（実装理解）

- [ ] ReActループ全体を追跡できる
- [ ] 新しいツールを追加できる
- [ ] グラフの流れを図示できる
- [ ] エラーハンドリングを理解している

### 上級レベル（カスタマイズ）

- [ ] 新しいノードを追加できる
- [ ] プロンプトを最適化できる
- [ ] パフォーマンスチューニングができる
- [ ] 独自のエージェントを設計できる

---

## 🔍 深掘り学習トピック

### 1. プロンプトエンジニアリング

```python
# 効果的なプロンプト設計のポイント
# 1. 明確な指示
# 2. 段階的な思考の誘導
# 3. 出力フォーマットの指定

# react_agent.pyのプロンプトを分析
# - なぜJSON出力を使用するのか？
# - ReActThoughtクラスの設計理由
# - few-shotプロンプティングの可能性
```

### 2. 状態管理のベストプラクティス

```python
# Immutable Stateパターンの利点
# - デバッグの容易さ
# - 履歴の追跡
# - 並行処理での安全性

# TypedDictを使う理由
# - 型安全性
# - IDE支援
# - ドキュメント性
```

### 3. エラー回復戦略

```python
# チェックポイントの設計思想
# - いつ保存するか
# - 何を保存するか
# - どのように復元するか

# エラーハンドリングのレベル
# - ツールレベル
# - ノードレベル
# - グラフレベル
```

---

## 🎓 発展的な学習リソース

### 論文・文献

1. **ReAct: Synergizing Reasoning and Acting in Language Models**
   - [arXiv:2210.03629](https://arxiv.org/abs/2210.03629)
   - ReActパターンの原論文

2. **LangGraph Documentation**
   - [公式ドキュメント](https://github.com/langchain-ai/langgraph)
   - グラフベースのエージェント設計

3. **Chain-of-Thought Prompting**
   - 段階的推論の重要性

### 実践プロジェクト

1. **カスタムエージェントの作成**
   - 特定タスク用のエージェント設計
   - ドメイン特化型ツールの実装

2. **マルチエージェントシステム**
   - Phase 4への準備
   - エージェント間の協調

3. **プロダクション対応**
   - スケーラビリティ
   - モニタリング
   - セキュリティ

---

## 🤝 コミュニティと質問

### 質問する前のチェックリスト

1. エラーメッセージを完全に読んだか
2. 関連するテストコードを確認したか
3. ログを詳細モードで確認したか
4. ドキュメントを検索したか

### 効果的な質問の仕方

```markdown
## 環境
- Python版: 3.x.x
- OS: macOS/Linux/Windows
- 関連パッケージ版: langchain==x.x.x

## 問題
[具体的な問題の説明]

## 試したこと
1. [試行1]
2. [試行2]

## エラーログ
```
[エラーメッセージ]
```

## 期待する動作
[期待する結果]
```

---

## 📝 学習ノートのテンプレート

各ファイルを学習する際に、以下のテンプレートでノートを作成することをお勧めします：

```markdown
# [ファイル名] 学習ノート

## 目的
このファイルの主な役割：

## 重要な概念
- 概念1：
- 概念2：

## キーとなるコード
```python
# 重要な部分のコード
```

## 理解したこと
- 

## 疑問点
- 

## 試したこと
- 

## 次のステップ
- 
```

---

*このガイドを通じて、AIエージェントの仕組みを深く理解し、独自のエージェントを開発できるスキルを身につけてください。*