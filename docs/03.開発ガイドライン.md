# 開発ガイドライン

## 📋 開発環境セットアップ

### 必要要件
- Python 3.11以上
- Git
- VSCode または Cursor（推奨）
- 4GB以上の空きメモリ

### 初期セットアップ
```bash
# 1. リポジトリのクローン
git clone https://github.com/yourusername/smart-docs-chat.git
cd smart-docs-chat

# 2. Python仮想環境の作成
python -m venv .venv

# 3. 仮想環境の有効化
# Mac/Linux:
source .venv/bin/activate
# Windows:
.venv\Scripts\activate

# 4. 依存パッケージのインストール
pip install --upgrade pip
pip install -r requirements.txt

# 5. 環境変数の設定
cp .env.example .env
# .envファイルを編集してAPIキーを設定
```

### 環境変数の設定
```bash
# .env ファイル
OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxx
COHERE_API_KEY=xxxxxxxxxxxxxxxxxxxx  # Phase 2で必要
LANGSMITH_API_KEY=xxxxxxxxxxxxxxxxxxxx  # オプション

# データソース設定
NOTION_TOKEN=secret_xxxxxxxxxxxxxxxxxxxx
NOTION_ROOT_PAGE_ID=xxxxxxxxxxxxxxxxxxxx
GOOGLE_DRIVE_FOLDER_IDS=folder_id1,folder_id2
GOOGLE_DRIVE_CREDENTIALS_PATH=./credentials/google_service_account.json
```

---

## 🎨 コーディング規約

### 基本原則
1. **可読性優先**: コードは書く時間より読む時間の方が長い
2. **明示的に**: 暗黙的より明示的な実装を心がける
3. **DRY原則**: Don't Repeat Yourself - 重複を避ける
4. **KISS原則**: Keep It Simple, Stupid - シンプルに保つ

### Pythonスタイルガイド
```python
# ファイル構成
"""
モジュールのdocstring
モジュールの目的と主な機能を記述
"""

# インポート順序
import os  # 1. 標準ライブラリ
import sys

from typing import List, Dict  # 2. 標準ライブラリの型

import numpy as np  # 3. サードパーティ
from langchain import LLMChain

from .local_module import helper  # 4. ローカルモジュール


# クラス定義
class AdvancedRAGChain:
    """
    Advanced RAGチェーンクラス
    
    HyDE、RAG-Fusion、Rerankerを統合した高度な検索拡張生成システム
    
    Attributes:
        vectorstore: ChromaDBベクトルストア
        llm: 言語モデルインスタンス
        reranker: リランカーモデル
    """
    
    def __init__(self, config: Dict):
        """
        初期化メソッド
        
        Args:
            config: 設定辞書
        """
        self.config = config
        self._initialize_components()
    
    def search_with_hyde(self, query: str, k: int = 10) -> List[Document]:
        """
        HyDEを使用した検索
        
        Args:
            query: 検索クエリ
            k: 取得する文書数
            
        Returns:
            関連文書のリスト
            
        Raises:
            ValueError: クエリが空の場合
        """
        if not query:
            raise ValueError("クエリが空です")
        
        # 実装
        hypothetical_answer = self._generate_hypothetical_answer(query)
        results = self.vectorstore.similarity_search(hypothetical_answer, k=k)
        
        return results


# 関数定義
def process_documents(
    documents: List[Document],
    chunk_size: int = 500,
    chunk_overlap: int = 100
) -> List[Document]:
    """
    ドキュメントをチャンクに分割
    
    長いドキュメントを適切なサイズのチャンクに分割し、
    ベクトル検索の精度を向上させる
    
    Args:
        documents: 処理するドキュメントのリスト
        chunk_size: チャンクのサイズ（文字数）
        chunk_overlap: チャンク間のオーバーラップ
        
    Returns:
        分割されたドキュメントのリスト
        
    Example:
        >>> docs = load_documents("./data")
        >>> chunks = process_documents(docs, chunk_size=1000)
        >>> print(f"分割数: {len(chunks)}")
    """
    # 実装
    pass


# 定数
MAX_RETRIES = 3  # 最大リトライ回数
DEFAULT_TEMPERATURE = 0.7  # デフォルトの温度パラメータ
EMBEDDING_MODEL = "text-embedding-3-small"  # 埋め込みモデル


# エラーハンドリング
try:
    result = risky_operation()
except SpecificError as e:
    logger.error(f"特定のエラーが発生: {e}")
    # 具体的なエラー処理
except Exception as e:
    logger.error(f"予期しないエラー: {e}")
    raise  # 再スロー
finally:
    # クリーンアップ処理
    cleanup_resources()
```

### 型ヒント
```python
from typing import List, Dict, Optional, Union, Tuple, Any
from typing import Callable, TypedDict, Literal
from typing_extensions import Annotated

# 基本的な型ヒント
def process_text(text: str) -> str:
    return text.lower()

# 複雑な型ヒント
def search_documents(
    query: str,
    filters: Optional[Dict[str, Any]] = None,
    k: int = 10
) -> Tuple[List[Document], List[float]]:
    pass

# TypedDictの使用
class SearchResult(TypedDict):
    document: Document
    score: float
    metadata: Dict[str, Any]

# Literalの使用
SearchType = Literal["semantic", "keyword", "hybrid"]

def perform_search(query: str, search_type: SearchType) -> List[Document]:
    pass
```

---

## 📝 ドキュメント規約

### Docstringフォーマット（Google Style）
```python
def complex_function(
    param1: str,
    param2: List[int],
    param3: Optional[Dict] = None
) -> Tuple[str, int]:
    """
    関数の簡潔な説明（1行）
    
    より詳細な説明。必要に応じて複数行で記述。
    この関数が何をするのか、なぜ必要なのかを説明。
    
    Args:
        param1: パラメータ1の説明
        param2: パラメータ2の説明
        param3: パラメータ3の説明（オプション）
        
    Returns:
        戻り値の説明。タプルの場合は各要素を説明。
        
    Raises:
        ValueError: 無効な入力の場合
        ConnectionError: API接続に失敗した場合
        
    Example:
        >>> result = complex_function("test", [1, 2, 3])
        >>> print(result)
        ("processed", 6)
        
    Note:
        この関数は内部的にキャッシュを使用します。
        
    See Also:
        simple_function: より簡単なバージョン
        advanced_function: より高度なバージョン
    """
    pass
```

### コメント規約
```python
# 良いコメントの例

# TODO: レート制限の実装が必要（2025年1月末までに）
# FIXME: メモリリークの可能性あり - 大量データ処理時に監視必要
# NOTE: このアルゴリズムはO(n log n)の計算量
# WARNING: この処理は副作用があります

# なぜこの処理が必要なのかを説明
# Notion APIは1秒あたり3リクエストまでなので、
# レート制限を避けるために待機時間を挿入
time.sleep(0.35)

# 悪いコメントの例
i += 1  # iに1を加える（自明なので不要）
```

---

## 🧪 テスト規約

### テストファイル構成
```
tests/
├── unit/           # 単体テスト
│   ├── test_hyde.py
│   ├── test_rag_fusion.py
│   └── test_reranker.py
├── integration/    # 統合テスト
│   ├── test_advanced_rag.py
│   └── test_langgraph_agent.py
└── fixtures/       # テストデータ
    └── sample_documents.json
```

### テストコード例
```python
import pytest
from unittest.mock import Mock, patch
from src.advanced_rag import HyDE

class TestHyDE:
    """HyDEクラスのテスト"""
    
    @pytest.fixture
    def hyde_instance(self):
        """HyDEインスタンスのフィクスチャ"""
        return HyDE(llm=Mock())
    
    def test_generate_hypothetical_answer(self, hyde_instance):
        """仮想回答生成のテスト"""
        # Arrange
        query = "Pythonのデコレータとは何ですか？"
        expected_answer = "Pythonのデコレータは..."
        hyde_instance.llm.generate.return_value = expected_answer
        
        # Act
        result = hyde_instance.generate_hypothetical_answer(query)
        
        # Assert
        assert result == expected_answer
        hyde_instance.llm.generate.assert_called_once_with(query)
    
    @pytest.mark.parametrize("query,expected", [
        ("", ValueError),
        (None, TypeError),
    ])
    def test_invalid_queries(self, hyde_instance, query, expected):
        """無効なクエリのテスト"""
        with pytest.raises(expected):
            hyde_instance.generate_hypothetical_answer(query)
```

---

## 🔀 Git運用

### ブランチ戦略
```
main
├── phase-2-advanced-rag     # Phase 2開発
│   ├── feature/hyde         # HyDE実装
│   ├── feature/rag-fusion   # RAG-Fusion実装
│   └── feature/reranker     # Reranker実装
├── phase-3-langgraph        # Phase 3開発
└── phase-4-multi-agent      # Phase 4開発
```

### コミットメッセージ
```bash
# 形式: <type>: <subject>

# 例
feat: HyDE検索機能を実装
fix: RAG-Fusionのスコア計算バグを修正
docs: Advanced RAGのREADMEを追加
refactor: チャンク分割ロジックをリファクタリング
test: HyDEの単体テストを追加
chore: 依存パッケージを更新

# 詳細な説明が必要な場合
feat: RAG-Fusionによる複数クエリ検索を実装

- 元のクエリから5つの関連クエリを生成
- 各クエリで並列検索を実行
- Reciprocal Rank Fusionで結果を統合
- 検索精度が約15%向上
```

### プルリクエスト
```markdown
## 概要
HyDE（Hypothetical Document Embeddings）機能を実装しました。

## 変更内容
- [ ] HyDEクラスの実装
- [ ] 仮想回答生成ロジック
- [ ] ベクトル検索との統合
- [ ] 単体テストの追加

## テスト結果
- 検索精度: 75% → 85%（+10%）
- 平均応答時間: 3.2秒

## レビューポイント
- 仮想回答の品質
- エラーハンドリング
- パフォーマンス

## 関連Issue
#123
```

---

## 🚀 デプロイメント

### ローカル実行
```bash
# Phase 2の実行
cd phase02-advanced-rag
python main.py --mode advanced

# Phase 3の実行
cd phase03-langgraph
python main.py --agent react

# デバッグモード
python main.py --debug --verbose
```

### Docker化
```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONUNBUFFERED=1

CMD ["python", "main.py"]
```

---

## 📊 パフォーマンス最適化

### プロファイリング
```python
import cProfile
import pstats

# プロファイリングの実行
profiler = cProfile.Profile()
profiler.enable()

# 処理実行
result = expensive_operation()

profiler.disable()
stats = pstats.Stats(profiler)
stats.sort_stats('cumulative')
stats.print_stats(10)  # 上位10個の関数を表示
```

### メモリ最適化
```python
# ジェネレータの使用
def process_large_dataset(files):
    for file in files:
        with open(file) as f:
            yield process_file(f)  # メモリ効率的

# デコレータでキャッシュ
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_computation(param):
    # 計算結果をキャッシュ
    return result
```

---

## 🐛 デバッグ

### ログ設定
```python
import logging

# ログ設定
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 使用例
logger.debug("デバッグ情報")
logger.info("通常情報")
logger.warning("警告")
logger.error("エラー")
logger.critical("致命的エラー")
```

### デバッグツール
```python
# pdbを使用したデバッグ
import pdb

def complex_function():
    x = 10
    pdb.set_trace()  # ここでブレークポイント
    y = x * 2
    return y

# Rich を使用した見やすい出力
from rich import print
from rich.console import Console

console = Console()
console.print("Hello", style="bold red")
console.print({"key": "value"})  # 自動的に整形
```

---

## 📚 参考資料

### 必読ドキュメント
- [PEP 8 - Style Guide for Python Code](https://pep8.org/)
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)
- [LangChain Best Practices](https://python.langchain.com/docs/guides/development/debugging)

### 推奨ツール
- **Black**: Pythonコードフォーマッター
- **Ruff**: 高速なPythonリンター
- **mypy**: 静的型チェッカー
- **pytest**: テストフレームワーク

---

*最終更新: 2025年1月21日*